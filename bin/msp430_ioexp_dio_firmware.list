
firmware.elf:     file format elf32-msp430


Disassembly of section .text:

0000c000 <__init_stack>:
    c000:	31 40 00 04 	mov	#1024,	r1	;#0x0400

0000c004 <__low_level_init>:
    c004:	15 42 20 01 	mov	&0x0120,r5	
    c008:	75 f3       	and.b	#-1,	r5	;r3 As==11
    c00a:	35 d0 08 5a 	bis	#23048,	r5	;#0x5a08

0000c00e <__do_copy_data>:
    c00e:	3f 40 30 00 	mov	#48,	r15	;#0x0030
    c012:	0f 93       	tst	r15		
    c014:	07 24       	jz	$+16     	;abs 0xc024
    c016:	82 45 20 01 	mov	r5,	&0x0120	
    c01a:	2f 83       	decd	r15		
    c01c:	9f 4f 7a c4 	mov	-15238(r15),512(r15);0xc47a(r15), 0x0200(r15)
    c020:	00 02 
    c022:	f9 23       	jnz	$-12     	;abs 0xc016

0000c024 <__do_clear_bss>:
    c024:	3f 40 3a 00 	mov	#58,	r15	;#0x003a
    c028:	0f 93       	tst	r15		
    c02a:	06 24       	jz	$+14     	;abs 0xc038
    c02c:	82 45 20 01 	mov	r5,	&0x0120	
    c030:	1f 83       	dec	r15		
    c032:	cf 43 30 02 	mov.b	#0,	560(r15);r3 As==00, 0x0230(r15)
    c036:	fa 23       	jnz	$-10     	;abs 0xc02c

0000c038 <main>:
	cmd_reset(0);
}

int main(void)
{
	clock_init();
    c038:	b0 12 52 c0 	call	#0xc052	
	gpio_init();
    c03c:	b0 12 68 c0 	call	#0xc068	
	i2c_cmd_init();
    c040:	b0 12 46 c2 	call	#0xc246	
	
	// serial_clk_init(16000000L, 9600);
	// cio_print("DIO - I2C Digital IO\n\r");

	while (1) {
		__asm__("nop");
    c044:	03 43       	nop			
    c046:	fe 3f       	jmp	$-2      	;abs 0xc044

0000c048 <__stop_progExec__>:
    c048:	32 d0 f0 00 	bis	#240,	r2	;#0x00f0
    c04c:	fd 3f       	jmp	$-4      	;abs 0xc048

0000c04e <__ctors_end>:
    c04e:	30 40 78 c4 	br	#0xc478	

0000c052 <clock_init>:
// #include "serial.h"
#include "cmd.h"

void clock_init(void)
{
    WDTCTL = WDTPW + WDTHOLD;
    c052:	b2 40 80 5a 	mov	#23168,	&0x0120	;#0x5a80
    c056:	20 01 
    BCSCTL1 = CALBC1_16MHZ;
    c058:	d2 42 f9 10 	mov.b	&0x10f9,&0x0057	
    c05c:	57 00 
    DCOCTL  = CALDCO_16MHZ;
    c05e:	d2 42 f8 10 	mov.b	&0x10f8,&0x0056	
    c062:	56 00 

    __bis_SR_register(GIE);
    c064:	32 d2       	eint			
}
    c066:	30 41       	ret			

0000c068 <gpio_init>:

void gpio_init(void)
{
	cmd_reset(0);
    c068:	0f 43       	clr	r15		
    c06a:	b0 12 48 c1 	call	#0xc148	
}
    c06e:	30 41       	ret			

0000c070 <cmd_set_pdir>:
#endif
}

void cmd_set_pdir(i2c_cmd_args *args)
{
	unsigned char p1 =  (args->args[0] & 0b00111111);
    c070:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
	unsigned char p2 = ((args->args[0] & 0b11000000) >> 6); 

#ifdef SERIAL_DEBUG
	P1DIR = (0b11000110 & P1DIR) | (p1 & 0b00111001);
#else
	P1DIR = (0b11000000 & P1DIR) | p1;
    c074:	5d 42 22 00 	mov.b	&0x0022,r13	
    c078:	7d f0 c0 ff 	and.b	#-64,	r13	;#0xffc0
#endif
}

void cmd_set_pdir(i2c_cmd_args *args)
{
	unsigned char p1 =  (args->args[0] & 0b00111111);
    c07c:	4e 4f       	mov.b	r15,	r14	
    c07e:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
	unsigned char p2 = ((args->args[0] & 0b11000000) >> 6); 

#ifdef SERIAL_DEBUG
	P1DIR = (0b11000110 & P1DIR) | (p1 & 0b00111001);
#else
	P1DIR = (0b11000000 & P1DIR) | p1;
    c082:	4d de       	bis.b	r14,	r13	
    c084:	c2 4d 22 00 	mov.b	r13,	&0x0022	
#endif
	P2DIR = (0b11111100 & P2DIR) | p2;
    c088:	5e 42 2a 00 	mov.b	&0x002a,r14	
    c08c:	7e f0 fc ff 	and.b	#-4,	r14	;#0xfffc
}

void cmd_set_pdir(i2c_cmd_args *args)
{
	unsigned char p1 =  (args->args[0] & 0b00111111);
	unsigned char p2 = ((args->args[0] & 0b11000000) >> 6); 
    c090:	12 c3       	clrc			
    c092:	4f 10       	rrc.b	r15		
    c094:	4f 11       	rra.b	r15		
    c096:	4f 11       	rra.b	r15		
    c098:	4f 11       	rra.b	r15		
    c09a:	4f 11       	rra.b	r15		
    c09c:	4f 11       	rra.b	r15		
#ifdef SERIAL_DEBUG
	P1DIR = (0b11000110 & P1DIR) | (p1 & 0b00111001);
#else
	P1DIR = (0b11000000 & P1DIR) | p1;
#endif
	P2DIR = (0b11111100 & P2DIR) | p2;
    c09e:	4e df       	bis.b	r15,	r14	
    c0a0:	c2 4e 2a 00 	mov.b	r14,	&0x002a	
	cio_printb(P1DIR, 8);
    cio_printf(", P2DIR: ");
	cio_printb(P2DIR, 8);
    cio_printf("\n\r");
#endif
}
    c0a4:	30 41       	ret			

0000c0a6 <cmd_set_pout>:

void cmd_set_pout(i2c_cmd_args *args)
{
	unsigned char p1 =  (args->args[0] & 0b00111111);
    c0a6:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
	unsigned char p2 = ((args->args[0] & 0b11000000) >> 6); 

#ifdef SERIAL_DEBUG
	P1OUT = (0b11000000 & P1OUT) | (p1 & 0b00111001);
#else
	P1OUT = (0b11000000 & P1OUT) | p1;
    c0aa:	5d 42 21 00 	mov.b	&0x0021,r13	
    c0ae:	7d f0 c0 ff 	and.b	#-64,	r13	;#0xffc0
#endif
}

void cmd_set_pout(i2c_cmd_args *args)
{
	unsigned char p1 =  (args->args[0] & 0b00111111);
    c0b2:	4e 4f       	mov.b	r15,	r14	
    c0b4:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
	unsigned char p2 = ((args->args[0] & 0b11000000) >> 6); 

#ifdef SERIAL_DEBUG
	P1OUT = (0b11000000 & P1OUT) | (p1 & 0b00111001);
#else
	P1OUT = (0b11000000 & P1OUT) | p1;
    c0b8:	4d de       	bis.b	r14,	r13	
    c0ba:	c2 4d 21 00 	mov.b	r13,	&0x0021	
#endif
	P2OUT = (0b11111100 & P2OUT) | p2;
    c0be:	5e 42 29 00 	mov.b	&0x0029,r14	
    c0c2:	7e f0 fc ff 	and.b	#-4,	r14	;#0xfffc
}

void cmd_set_pout(i2c_cmd_args *args)
{
	unsigned char p1 =  (args->args[0] & 0b00111111);
	unsigned char p2 = ((args->args[0] & 0b11000000) >> 6); 
    c0c6:	12 c3       	clrc			
    c0c8:	4f 10       	rrc.b	r15		
    c0ca:	4f 11       	rra.b	r15		
    c0cc:	4f 11       	rra.b	r15		
    c0ce:	4f 11       	rra.b	r15		
    c0d0:	4f 11       	rra.b	r15		
    c0d2:	4f 11       	rra.b	r15		
#ifdef SERIAL_DEBUG
	P1OUT = (0b11000000 & P1OUT) | (p1 & 0b00111001);
#else
	P1OUT = (0b11000000 & P1OUT) | p1;
#endif
	P2OUT = (0b11111100 & P2OUT) | p2;
    c0d4:	4e df       	bis.b	r15,	r14	
    c0d6:	c2 4e 29 00 	mov.b	r14,	&0x0029	
	cio_printb(P1OUT, 8);
    cio_printf(", P2OUT: ");
	cio_printb(P2OUT, 8);
    cio_printf("\n\r");
#endif
}
    c0da:	30 41       	ret			

0000c0dc <cmd_set_pir>:
#endif
}

void cmd_set_pir(i2c_cmd_args *args)
{
	unsigned char p1 =  (args->args[0] & 0b00111111);
    c0dc:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
	unsigned char p2 = ((args->args[0] & 0b11000000) >> 6); 

#ifdef SERIAL_DEBUG
	P1IE = (0b11000000 & P1OUT) | (p1 & 0b00111001);
#else
	P1IE = (0b11000000 & P1OUT) | p1;
    c0e0:	5d 42 21 00 	mov.b	&0x0021,r13	
    c0e4:	7d f0 c0 ff 	and.b	#-64,	r13	;#0xffc0
#endif
}

void cmd_set_pir(i2c_cmd_args *args)
{
	unsigned char p1 =  (args->args[0] & 0b00111111);
    c0e8:	4e 4f       	mov.b	r15,	r14	
    c0ea:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
	unsigned char p2 = ((args->args[0] & 0b11000000) >> 6); 

#ifdef SERIAL_DEBUG
	P1IE = (0b11000000 & P1OUT) | (p1 & 0b00111001);
#else
	P1IE = (0b11000000 & P1OUT) | p1;
    c0ee:	4d de       	bis.b	r14,	r13	
    c0f0:	c2 4d 25 00 	mov.b	r13,	&0x0025	
#endif
	P2IE = (0b11111100 & P2OUT) | p2;
    c0f4:	5e 42 29 00 	mov.b	&0x0029,r14	
    c0f8:	7e f0 fc ff 	and.b	#-4,	r14	;#0xfffc
}

void cmd_set_pir(i2c_cmd_args *args)
{
	unsigned char p1 =  (args->args[0] & 0b00111111);
	unsigned char p2 = ((args->args[0] & 0b11000000) >> 6); 
    c0fc:	12 c3       	clrc			
    c0fe:	4f 10       	rrc.b	r15		
    c100:	4f 11       	rra.b	r15		
    c102:	4f 11       	rra.b	r15		
    c104:	4f 11       	rra.b	r15		
    c106:	4f 11       	rra.b	r15		
    c108:	4f 11       	rra.b	r15		
#ifdef SERIAL_DEBUG
	P1IE = (0b11000000 & P1OUT) | (p1 & 0b00111001);
#else
	P1IE = (0b11000000 & P1OUT) | p1;
#endif
	P2IE = (0b11111100 & P2OUT) | p2;
    c10a:	4e df       	bis.b	r15,	r14	
    c10c:	c2 4e 2d 00 	mov.b	r14,	&0x002d	
	cio_printb(P1IE, 8);
    cio_printf(", P2IE: ");
	cio_printb(P2IE, 8);
    cio_printf("\n\r");
#endif
}
    c110:	30 41       	ret			

0000c112 <cmd_set_ren>:
#endif
}

void cmd_set_ren(i2c_cmd_args *args)
{
	unsigned char p1 =  (args->args[0] & 0b00111111);
    c112:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
	unsigned char p2 = ((args->args[0] & 0b11000000) >> 6); 

#ifdef SERIAL_DEBUG
	P1REN = (0b11000000 & P1REN) | p1;
#else
	P1REN = (0b11000000 & P1REN) | (p1 & 0b00111001);
    c116:	4d 4f       	mov.b	r15,	r13	
    c118:	7d f0 39 00 	and.b	#57,	r13	;#0x0039
    c11c:	5e 42 27 00 	mov.b	&0x0027,r14	
    c120:	7e f0 c0 ff 	and.b	#-64,	r14	;#0xffc0
    c124:	4d de       	bis.b	r14,	r13	
    c126:	c2 4d 27 00 	mov.b	r13,	&0x0027	
#endif
	P2REN = (0b11111100 & P2REN) | p2;
    c12a:	5e 42 2f 00 	mov.b	&0x002f,r14	
    c12e:	7e f0 fc ff 	and.b	#-4,	r14	;#0xfffc
}

void cmd_set_ren(i2c_cmd_args *args)
{
	unsigned char p1 =  (args->args[0] & 0b00111111);
	unsigned char p2 = ((args->args[0] & 0b11000000) >> 6); 
    c132:	12 c3       	clrc			
    c134:	4f 10       	rrc.b	r15		
    c136:	4f 11       	rra.b	r15		
    c138:	4f 11       	rra.b	r15		
    c13a:	4f 11       	rra.b	r15		
    c13c:	4f 11       	rra.b	r15		
    c13e:	4f 11       	rra.b	r15		
#ifdef SERIAL_DEBUG
	P1REN = (0b11000000 & P1REN) | p1;
#else
	P1REN = (0b11000000 & P1REN) | (p1 & 0b00111001);
#endif
	P2REN = (0b11111100 & P2REN) | p2;
    c140:	4e df       	bis.b	r15,	r14	
    c142:	c2 4e 2f 00 	mov.b	r14,	&0x002f	
	cio_printb(P1REN, 8);
    cio_printf(", P2REN: ");
	cio_printb(P2REN, 8);
    cio_printf("\n\r");
#endif
}
    c146:	30 41       	ret			

0000c148 <cmd_reset>:
void cmd_reset(i2c_cmd_args *args)
{
	P1DIR &= 0b11111111;
	P2DIR &= 0b11111111;

	P1OUT &= 0b11000000;
    c148:	f2 f0 c0 ff 	and.b	#-64,	&0x0021	;#0xffc0
    c14c:	21 00 
	P2OUT &= 0b11111100;
    c14e:	f2 f0 fc ff 	and.b	#-4,	&0x0029	;#0xfffc
    c152:	29 00 

	P1REN &= 0b11000000;
    c154:	f2 f0 c0 ff 	and.b	#-64,	&0x0027	;#0xffc0
    c158:	27 00 
	P2REN &= 0b11111100;
    c15a:	f2 f0 fc ff 	and.b	#-4,	&0x002f	;#0xfffc
    c15e:	2f 00 

	P1SEL &= 0b11000100;
    c160:	f2 f0 c4 ff 	and.b	#-60,	&0x0026	;#0xffc4
    c164:	26 00 
	P2SEL &= 0b11111100;
    c166:	f2 f0 fc ff 	and.b	#-4,	&0x002e	;#0xfffc
    c16a:	2e 00 

	P1IE &= 0b11000000;
    c16c:	f2 f0 c0 ff 	and.b	#-64,	&0x0025	;#0xffc0
    c170:	25 00 
	P2IE &= 0b11111100;
    c172:	f2 f0 fc ff 	and.b	#-4,	&0x002d	;#0xfffc
    c176:	2d 00 

	interrupt_flags = 0;
    c178:	c2 43 30 02 	mov.b	#0,	&0x0230	;r3 As==00

	interrupt_cnt[0] = 0;
    c17c:	3f 40 32 02 	mov	#562,	r15	;#0x0232
    c180:	8f 43 00 00 	mov	#0,	0(r15)	;r3 As==00, 0x0000(r15)
	interrupt_cnt[1] = 0;
    c184:	8f 43 02 00 	mov	#0,	2(r15)	;r3 As==00, 0x0002(r15)
	interrupt_cnt[2] = 0;
    c188:	8f 43 04 00 	mov	#0,	4(r15)	;r3 As==00, 0x0004(r15)
	interrupt_cnt[3] = 0;
    c18c:	8f 43 06 00 	mov	#0,	6(r15)	;r3 As==00, 0x0006(r15)
	interrupt_cnt[4] = 0;
    c190:	8f 43 08 00 	mov	#0,	8(r15)	;r3 As==00, 0x0008(r15)
	interrupt_cnt[5] = 0;
    c194:	8f 43 0a 00 	mov	#0,	10(r15)	;r3 As==00, 0x000a(r15)
	interrupt_cnt[6] = 0;
    c198:	8f 43 0c 00 	mov	#0,	12(r15)	;r3 As==00, 0x000c(r15)
	interrupt_cnt[7] = 0;
    c19c:	8f 43 0e 00 	mov	#0,	14(r15)	;r3 As==00, 0x000e(r15)

#ifdef SERIAL_DEBUG
	cio_printf("%s\n\r", __func__);
#endif
}
    c1a0:	30 41       	ret			

0000c1a2 <cmd_get_fwversion>:

void cmd_get_fwversion(i2c_cmd_args *args)
{
	// FIXME: add to global defines
	// current fw-version
	i2cslave_cmdproc_clrres();
    c1a2:	b0 12 f0 c3 	call	#0xc3f0	
	i2cslave_cmdproc_addres(0x42);
    c1a6:	7f 40 42 00 	mov.b	#66,	r15	;#0x0042
    c1aa:	b0 12 0a c4 	call	#0xc40a	

#ifdef SERIAL_DEBUG
	cio_printf("%s\n\r", __func__);
#endif
}
    c1ae:	30 41       	ret			

0000c1b0 <cmd_get_fwtype>:

void cmd_get_fwtype(i2c_cmd_args *args)
{
	// FIXME: add to global defines
	// 0x01 = DIO
	i2cslave_cmdproc_clrres();
    c1b0:	b0 12 f0 c3 	call	#0xc3f0	
	i2cslave_cmdproc_addres(0x01);
    c1b4:	5f 43       	mov.b	#1,	r15	;r3 As==01
    c1b6:	b0 12 0a c4 	call	#0xc40a	

#ifdef SERIAL_DEBUG
	cio_printf("%s\n\r", __func__);
#endif
}
    c1ba:	30 41       	ret			

0000c1bc <cmd_get_pirc>:
	i2cslave_cmdproc_addres(interrupt_flags);
	interrupt_flags = 0;
}

void cmd_get_pirc(i2c_cmd_args *args)
{
    c1bc:	0b 12       	push	r11		
    c1be:	0a 12       	push	r10		
	unsigned char low = 0xff;
	unsigned char hi  = 0xff;

	if(args->args[0] <= 7) {
    c1c0:	5f 4f 01 00 	mov.b	1(r15),	r15	;0x0001(r15)
    c1c4:	7f 92       	cmp.b	#8,	r15	;r2 As==11
    c1c6:	07 2c       	jc	$+16     	;abs 0xc1d6
		low = (unsigned char)(interrupt_cnt[args->args[0]]);
    c1c8:	4f 4f       	mov.b	r15,	r15	
    c1ca:	0f 5f       	rla	r15		
    c1cc:	1b 4f 32 02 	mov	562(r15),r11	;0x0232(r15)
    c1d0:	4a 4b       	mov.b	r11,	r10	
		hi  = (unsigned char)(interrupt_cnt[args->args[0]] >> 8);
    c1d2:	8b 10       	swpb	r11		
    c1d4:	02 3c       	jmp	$+6      	;abs 0xc1da
}

void cmd_get_pirc(i2c_cmd_args *args)
{
	unsigned char low = 0xff;
	unsigned char hi  = 0xff;
    c1d6:	7b 43       	mov.b	#-1,	r11	;r3 As==11
	interrupt_flags = 0;
}

void cmd_get_pirc(i2c_cmd_args *args)
{
	unsigned char low = 0xff;
    c1d8:	4a 4b       	mov.b	r11,	r10	
	if(args->args[0] <= 7) {
		low = (unsigned char)(interrupt_cnt[args->args[0]]);
		hi  = (unsigned char)(interrupt_cnt[args->args[0]] >> 8);
	}

	i2cslave_cmdproc_clrres();
    c1da:	b0 12 f0 c3 	call	#0xc3f0	
	i2cslave_cmdproc_addres(hi);
    c1de:	4f 4b       	mov.b	r11,	r15	
    c1e0:	b0 12 0a c4 	call	#0xc40a	
	i2cslave_cmdproc_addres(low);
    c1e4:	4f 4a       	mov.b	r10,	r15	
    c1e6:	b0 12 0a c4 	call	#0xc40a	
	cio_printb(hi, 8);
	cio_printf(" ");
	cio_printb(low, 8);
    cio_printf("\n\r");
#endif
}
    c1ea:	3a 41       	pop	r10		
    c1ec:	3b 41       	pop	r11		
    c1ee:	30 41       	ret			

0000c1f0 <cmd_get_pir>:
    cio_printf("%s::interrupt_flags:", __func__);
	cio_printb(interrupt_flags, 8);
    cio_printf("\n\r");
#endif

	i2cslave_cmdproc_clrres();
    c1f0:	b0 12 f0 c3 	call	#0xc3f0	
	i2cslave_cmdproc_addres(interrupt_flags);
    c1f4:	5f 42 30 02 	mov.b	&0x0230,r15	
    c1f8:	b0 12 0a c4 	call	#0xc40a	
	interrupt_flags = 0;
    c1fc:	c2 43 30 02 	mov.b	#0,	&0x0230	;r3 As==00
}
    c200:	30 41       	ret			

0000c202 <cmd_get_pin>:
    cio_printf("\n\r");
#endif
}

void cmd_get_pin(i2c_cmd_args *args)
{
    c202:	0b 12       	push	r11		
    c204:	0a 12       	push	r10		
    c206:	09 12       	push	r9		
    c208:	08 12       	push	r8		
	unsigned char p1 =  0b00111111 & P1IN & ~P1DIR; 
    c20a:	5a 42 20 00 	mov.b	&0x0020,r10	
    c20e:	5b 42 22 00 	mov.b	&0x0022,r11	
	unsigned char p2 = (0b00000011 & P2IN & ~P2DIR) << 6; 
    c212:	59 42 28 00 	mov.b	&0x0028,r9	
    c216:	58 42 2a 00 	mov.b	&0x002a,r8	

	i2cslave_cmdproc_clrres();
    c21a:	b0 12 f0 c3 	call	#0xc3f0	
}

void cmd_get_pin(i2c_cmd_args *args)
{
	unsigned char p1 =  0b00111111 & P1IN & ~P1DIR; 
	unsigned char p2 = (0b00000011 & P2IN & ~P2DIR) << 6; 
    c21e:	4e 49       	mov.b	r9,	r14	
    c220:	4e c8       	bic.b	r8,	r14	
    c222:	4e 5e       	rla.b	r14		
    c224:	4e 5e       	rla.b	r14		
    c226:	4e 5e       	rla.b	r14		
    c228:	4e 5e       	rla.b	r14		
    c22a:	4e 5e       	rla.b	r14		
    c22c:	4e 5e       	rla.b	r14		
#endif
}

void cmd_get_pin(i2c_cmd_args *args)
{
	unsigned char p1 =  0b00111111 & P1IN & ~P1DIR; 
    c22e:	4f 4a       	mov.b	r10,	r15	
    c230:	7f f0 3f 00 	and.b	#63,	r15	;#0x003f
    c234:	4f cb       	bic.b	r11,	r15	
	unsigned char p2 = (0b00000011 & P2IN & ~P2DIR) << 6; 

	i2cslave_cmdproc_clrres();
	i2cslave_cmdproc_addres(p1 | p2);
    c236:	4f de       	bis.b	r14,	r15	
    c238:	b0 12 0a c4 	call	#0xc40a	
#ifdef SERIAL_DEBUG
    cio_printf("%s::p1 | p2:", __func__);
	cio_printb(p1 | p2, 8);
    cio_printf("\n\r");
#endif
}
    c23c:	38 41       	pop	r8		
    c23e:	39 41       	pop	r9		
    c240:	3a 41       	pop	r10		
    c242:	3b 41       	pop	r11		
    c244:	30 41       	ret			

0000c246 <i2c_cmd_init>:

static unsigned int	 interrupt_cnt[] = {0, 0, 0, 0, 0, 0, 0, 0};

void i2c_cmd_init()
{
	i2cslave_cmdproc_init(I2C_ADDR, &cmds);
    c246:	3e 40 00 02 	mov	#512,	r14	;#0x0200
    c24a:	3f 40 48 00 	mov	#72,	r15	;#0x0048
    c24e:	b0 12 e2 c3 	call	#0xc3e2	

#ifdef SERIAL_DEBUG
	serial_clk_init(16000000L, 9600);
    cio_printf("%s\n\r", __func__);
#endif
}
    c252:	30 41       	ret			

0000c254 <PORT1_ISR>:
	cio_printf("%s\n\r", __func__);
#endif
}

interrupt(PORT1_VECTOR) PORT1_ISR(void)
{
    c254:	0f 12       	push	r15		
    c256:	0e 12       	push	r14		
	unsigned char p1 = (0b00111111 & P1IFG & P1IE); 
    c258:	5f 42 23 00 	mov.b	&0x0023,r15	
    c25c:	5f f2 25 00 	and.b	&0x0025,r15	
    c260:	7f f0 3f 00 	and.b	#63,	r15	;#0x003f

	interrupt_flags = (interrupt_flags & 0b11000000) | p1;
    c264:	5e 42 30 02 	mov.b	&0x0230,r14	
    c268:	7e f0 c0 ff 	and.b	#-64,	r14	;#0xffc0
    c26c:	4e df       	bis.b	r15,	r14	
    c26e:	c2 4e 30 02 	mov.b	r14,	&0x0230	

	if(p1 & 0b00000001) {
    c272:	4f 4f       	mov.b	r15,	r15	
    c274:	1f b3       	bit	#1,	r15	;r3 As==01
    c276:	02 24       	jz	$+6      	;abs 0xc27c
		interrupt_cnt[0]++;
    c278:	92 53 32 02 	inc	&0x0232	
	}
	if(p1 & 0b00000010) {
    c27c:	2f b3       	bit	#2,	r15	;r3 As==10
    c27e:	02 24       	jz	$+6      	;abs 0xc284
		interrupt_cnt[1]++;
    c280:	92 53 34 02 	inc	&0x0234	
	}
	if(p1 & 0b00000100) {
    c284:	2f b2       	bit	#4,	r15	;r2 As==10
    c286:	02 24       	jz	$+6      	;abs 0xc28c
		interrupt_cnt[2]++;
    c288:	92 53 36 02 	inc	&0x0236	
	}
	if(p1 & 0b00001000) {
    c28c:	3f b2       	bit	#8,	r15	;r2 As==11
    c28e:	02 24       	jz	$+6      	;abs 0xc294
		interrupt_cnt[3]++;
    c290:	92 53 38 02 	inc	&0x0238	
	}
	if(p1 & 0b00010000) {
    c294:	3f b0 10 00 	bit	#16,	r15	;#0x0010
    c298:	02 24       	jz	$+6      	;abs 0xc29e
		interrupt_cnt[4]++;
    c29a:	92 53 3a 02 	inc	&0x023a	
	}
	if(p1 & 0b00100000) {
    c29e:	3f f0 20 00 	and	#32,	r15	;#0x0020
    c2a2:	02 24       	jz	$+6      	;abs 0xc2a8
		interrupt_cnt[5]++;
    c2a4:	92 53 3c 02 	inc	&0x023c	
	}

	P1IFG = 0;
    c2a8:	c2 43 23 00 	mov.b	#0,	&0x0023	;r3 As==00
}
    c2ac:	3e 41       	pop	r14		
    c2ae:	3f 41       	pop	r15		
    c2b0:	00 13       	reti			

0000c2b2 <PORT2_ISR>:

interrupt(PORT2_VECTOR) PORT2_ISR(void)
{
    c2b2:	0f 12       	push	r15		
    c2b4:	0e 12       	push	r14		
	unsigned char p2 = (0b00000011 & P2IFG & P2IE) << 6; 
    c2b6:	5f 42 2d 00 	mov.b	&0x002d,r15	
    c2ba:	5f f2 2b 00 	and.b	&0x002b,r15	
    c2be:	4f 4f       	mov.b	r15,	r15	
    c2c0:	0f 5f       	rla	r15		
    c2c2:	0f 5f       	rla	r15		
    c2c4:	0f 5f       	rla	r15		
    c2c6:	0f 5f       	rla	r15		
    c2c8:	0f 5f       	rla	r15		

	interrupt_flags = (interrupt_flags & 0b00111111) | p2;
    c2ca:	4f 5f       	rla.b	r15		
    c2cc:	5e 42 30 02 	mov.b	&0x0230,r14	
    c2d0:	7e f0 3f 00 	and.b	#63,	r14	;#0x003f
    c2d4:	4e df       	bis.b	r15,	r14	
    c2d6:	c2 4e 30 02 	mov.b	r14,	&0x0230	

	if(p2 & 0b01000000) {
    c2da:	3f b0 40 00 	bit	#64,	r15	;#0x0040
    c2de:	02 24       	jz	$+6      	;abs 0xc2e4
		interrupt_cnt[6]++;
    c2e0:	92 53 3e 02 	inc	&0x023e	
	}
	if(p2 & 0b10000000) {
    c2e4:	4f 93       	tst.b	r15		
    c2e6:	02 34       	jge	$+6      	;abs 0xc2ec
		interrupt_cnt[7]++;
    c2e8:	92 53 40 02 	inc	&0x0240	
	}

	P2IFG = 0;
    c2ec:	c2 43 2b 00 	mov.b	#0,	&0x002b	;r3 As==00
}
    c2f0:	3e 41       	pop	r14		
    c2f2:	3f 41       	pop	r15		
    c2f4:	00 13       	reti			

0000c2f6 <i2cslave_cmdproc_receive_cb>:

	return -1;
}

static void i2cslave_cmdproc_receive_cb(unsigned char data)
{
    c2f6:	0b 12       	push	r11		
    c2f8:	0a 12       	push	r10		
	int i;

	if(i2cslave_cmdproc_last_cmd == -1) {
    c2fa:	1c 42 62 02 	mov	&0x0262,r12	
    c2fe:	1d 42 60 02 	mov	&0x0260,r13	
    c302:	3c 93       	cmp	#-1,	r12	;r3 As==11
    c304:	17 20       	jnz	$+48     	;abs 0xc334
		// not yet received command, see if data is known command
		for(i = 0; i < i2cslave_cmdproc_cmds->count; i++) {
    c306:	6b 4d       	mov.b	@r13,	r11	
	}

	return -1;
}

static void i2cslave_cmdproc_receive_cb(unsigned char data)
    c308:	0c 4d       	mov	r13,	r12	
    c30a:	2c 53       	incd	r12		
    c30c:	0e 43       	clr	r14		
    c30e:	0f 3c       	jmp	$+32     	;abs 0xc32e
	int i;

	if(i2cslave_cmdproc_last_cmd == -1) {
		// not yet received command, see if data is known command
		for(i = 0; i < i2cslave_cmdproc_cmds->count; i++) {
			if(data == i2cslave_cmdproc_cmds->cmds[i].cmd) {
    c310:	6a 4c       	mov.b	@r12,	r10	
    c312:	2c 52       	add	#4,	r12	;r2 As==10
    c314:	4f 9a       	cmp.b	r10,	r15	
    c316:	0a 20       	jnz	$+22     	;abs 0xc32c
				i2cslave_cmdproc_last_cmd = i;
    c318:	82 4e 62 02 	mov	r14,	&0x0262	
				if(i2cslave_cmdproc_cmds->cmds[i2cslave_cmdproc_last_cmd].args == 0) {
    c31c:	0f 4e       	mov	r14,	r15	
    c31e:	0f 5f       	rla	r15		
    c320:	0f 5f       	rla	r15		
    c322:	0f 5d       	add	r13,	r15	
    c324:	cf 93 03 00 	tst.b	3(r15)		;0x0003(r15)
    c328:	20 20       	jnz	$+66     	;abs 0xc36a
    c32a:	18 3c       	jmp	$+50     	;abs 0xc35c
{
	int i;

	if(i2cslave_cmdproc_last_cmd == -1) {
		// not yet received command, see if data is known command
		for(i = 0; i < i2cslave_cmdproc_cmds->count; i++) {
    c32c:	1e 53       	inc	r14		
    c32e:	0e 9b       	cmp	r11,	r14	
    c330:	ef 3b       	jl	$-32     	;abs 0xc310
    c332:	1b 3c       	jmp	$+56     	;abs 0xc36a
			}
		}
	}
	else {
		// already received command, see if data needs to be added to params
		if(i2cslave_cmdproc_last_args.count < i2cslave_cmdproc_cmds->cmds[i2cslave_cmdproc_last_cmd].args) {
    c334:	5b 42 64 02 	mov.b	&0x0264,r11	
    c338:	0e 4c       	mov	r12,	r14	
    c33a:	0e 5e       	rla	r14		
    c33c:	0e 5e       	rla	r14		
    c33e:	0e 5d       	add	r13,	r14	
    c340:	2e 53       	incd	r14		
    c342:	5b 9e 01 00 	cmp.b	1(r14),	r11	;0x0001(r14)
    c346:	11 2c       	jc	$+36     	;abs 0xc36a
			i2cslave_cmdproc_last_args.args[i2cslave_cmdproc_last_args.count++] = data;
    c348:	4a 4b       	mov.b	r11,	r10	
    c34a:	ca 4f 65 02 	mov.b	r15,	613(r10);0x0265(r10)
    c34e:	5b 53       	inc.b	r11		
    c350:	c2 4b 64 02 	mov.b	r11,	&0x0264	

			if(i2cslave_cmdproc_last_args.count == i2cslave_cmdproc_cmds->cmds[i2cslave_cmdproc_last_cmd].args) {
    c354:	5b 9e 01 00 	cmp.b	1(r14),	r11	;0x0001(r14)
    c358:	08 20       	jnz	$+18     	;abs 0xc36a
				i2cslave_cmdproc_cmds->cmds[i2cslave_cmdproc_last_cmd].func(&i2cslave_cmdproc_last_args);
    c35a:	0e 4c       	mov	r12,	r14	
    c35c:	1e 53       	inc	r14		
    c35e:	0e 5e       	rla	r14		
    c360:	0e 5e       	rla	r14		
    c362:	0e 5d       	add	r13,	r14	
    c364:	3f 40 64 02 	mov	#612,	r15	;#0x0264
    c368:	ae 12       	call	@r14		
			}
		}
	}
}
    c36a:	3a 41       	pop	r10		
    c36c:	3b 41       	pop	r11		
    c36e:	30 41       	ret			

0000c370 <i2cslave_cmdproc_transmit_cb>:

static void i2cslave_cmdproc_transmit_cb(unsigned char volatile *data)
{
	if(i2cslave_cmdproc_res.xmit_count < i2cslave_cmdproc_res.count) {
    c370:	5e 42 45 02 	mov.b	&0x0245,r14	
    c374:	5e 92 44 02 	cmp.b	&0x0244,r14	
    c378:	08 2c       	jc	$+18     	;abs 0xc38a
		*data = i2cslave_cmdproc_res.data[i2cslave_cmdproc_res.xmit_count++];
    c37a:	4d 4e       	mov.b	r14,	r13	
    c37c:	df 4d 46 02 	mov.b	582(r13),0(r15)	;0x0246(r13), 0x0000(r15)
    c380:	00 00 
    c382:	5e 53       	inc.b	r14		
    c384:	c2 4e 45 02 	mov.b	r14,	&0x0245	
    c388:	30 41       	ret			
	}
	else {
		*data = 0xff;
    c38a:	ff 43 00 00 	mov.b	#-1,	0(r15)	;r3 As==11, 0x0000(r15)
    c38e:	30 41       	ret			

0000c390 <i2cslave_cmdproc_start_cb>:

static void i2cslave_cmdproc_start_cb()
{
	int i; 

	i2cslave_cmdproc_last_cmd = -1;
    c390:	b2 43 62 02 	mov	#-1,	&0x0262	;r3 As==11
	i2cslave_cmdproc_last_args.count = 0;
    c394:	3f 40 64 02 	mov	#612,	r15	;#0x0264
    c398:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)

	for(i = 0; i < I2C_MAX_ARGS; i++) {
		i2cslave_cmdproc_last_args.args[i] = 0;
    c39c:	cf 43 01 00 	mov.b	#0,	1(r15)	;r3 As==00, 0x0001(r15)
    c3a0:	cf 43 02 00 	mov.b	#0,	2(r15)	;r3 As==00, 0x0002(r15)
    c3a4:	cf 43 03 00 	mov.b	#0,	3(r15)	;r3 As==00, 0x0003(r15)
    c3a8:	cf 43 04 00 	mov.b	#0,	4(r15)	;r3 As==00, 0x0004(r15)
    c3ac:	cf 43 05 00 	mov.b	#0,	5(r15)	;r3 As==00, 0x0005(r15)
	}
}
    c3b0:	30 41       	ret			

0000c3b2 <i2cslave_init>:

static i2c_cmds *i2cslave_cmdproc_cmds;

void i2cslave_init(unsigned int addr, i2c_cb *callbacks)
{
     i2c_callbacks = callbacks;
    c3b2:	82 4e 42 02 	mov	r14,	&0x0242	

     P1SEL 		|= I2C_SDA + I2C_SCL;
    c3b6:	f2 d0 c0 ff 	bis.b	#-64,	&0x0026	;#0xffc0
    c3ba:	26 00 
     P1SEL2 	|= I2C_SDA + I2C_SCL;
    c3bc:	f2 d0 c0 ff 	bis.b	#-64,	&0x0041	;#0xffc0
    c3c0:	41 00 
     UCB0CTL1 	|= UCSWRST;
    c3c2:	d2 d3 69 00 	bis.b	#1,	&0x0069	;r3 As==01
     UCB0CTL0 	 = UCMODE_3 + UCSYNC;
    c3c6:	f2 40 07 00 	mov.b	#7,	&0x0068	;#0x0007
    c3ca:	68 00 
     UCB0I2COA 	 = addr;
    c3cc:	82 4f 18 01 	mov	r15,	&0x0118	
     UCB0CTL1 	&= ~UCSWRST;
    c3d0:	f2 f0 fe ff 	and.b	#-2,	&0x0069	;#0xfffe
    c3d4:	69 00 
     IE2 		|= UCB0TXIE + UCB0RXIE;
    c3d6:	f2 d0 0c 00 	bis.b	#12,	&0x0001	;#0x000c
    c3da:	01 00 
     UCB0I2CIE 	|= UCSTTIE;
    c3dc:	e2 d3 6c 00 	bis.b	#2,	&0x006c	;r3 As==10
}
    c3e0:	30 41       	ret			

0000c3e2 <i2cslave_cmdproc_init>:

void i2cslave_cmdproc_init(unsigned int addr, i2c_cmds *cmds) 
{
	i2cslave_cmdproc_cmds = cmds;
    c3e2:	82 4e 60 02 	mov	r14,	&0x0260	

	i2cslave_init(addr, &i2cslave_cmdproc_cbs); 
    c3e6:	3e 40 2a 02 	mov	#554,	r14	;#0x022a
    c3ea:	b0 12 b2 c3 	call	#0xc3b2	
}
    c3ee:	30 41       	ret			

0000c3f0 <i2cslave_cmdproc_clrres>:

void i2cslave_cmdproc_clrres() 
{
	int i;

	i2cslave_cmdproc_res.count = 0;
    c3f0:	c2 43 44 02 	mov.b	#0,	&0x0244	;r3 As==00
	i2cslave_cmdproc_res.xmit_count = 0;
    c3f4:	c2 43 45 02 	mov.b	#0,	&0x0245	;r3 As==00
    c3f8:	3f 40 46 02 	mov	#582,	r15	;#0x0246

	for(i = 0; i < I2C_MAX_RES; i++) {
		i2cslave_cmdproc_res.data[i] = 0;
    c3fc:	cf 43 00 00 	mov.b	#0,	0(r15)	;r3 As==00, 0x0000(r15)
    c400:	1f 53       	inc	r15		
	int i;

	i2cslave_cmdproc_res.count = 0;
	i2cslave_cmdproc_res.xmit_count = 0;

	for(i = 0; i < I2C_MAX_RES; i++) {
    c402:	3f 90 5f 02 	cmp	#607,	r15	;#0x025f
    c406:	fa 23       	jnz	$-10     	;abs 0xc3fc
		i2cslave_cmdproc_res.data[i] = 0;
	}
}
    c408:	30 41       	ret			

0000c40a <i2cslave_cmdproc_addres>:

int i2cslave_cmdproc_addres(unsigned char data) 
{
	if(i2cslave_cmdproc_res.count < I2C_MAX_RES) {
    c40a:	5e 42 44 02 	mov.b	&0x0244,r14	
    c40e:	7e 90 19 00 	cmp.b	#25,	r14	;#0x0019
    c412:	08 2c       	jc	$+18     	;abs 0xc424
		i2cslave_cmdproc_res.data[i2cslave_cmdproc_res.count++] = data;	
    c414:	4d 4e       	mov.b	r14,	r13	
    c416:	cd 4f 46 02 	mov.b	r15,	582(r13);0x0246(r13)
    c41a:	5e 53       	inc.b	r14		
    c41c:	c2 4e 44 02 	mov.b	r14,	&0x0244	
		return 0;
    c420:	0f 43       	clr	r15		
    c422:	30 41       	ret			
	}

	return -1;
    c424:	3f 43       	mov	#-1,	r15	;r3 As==11
}
    c426:	30 41       	ret			

0000c428 <i2c_data_interrupt>:
		i2cslave_cmdproc_last_args.args[i] = 0;
	}
}

interrupt(USCIAB0TX_VECTOR) i2c_data_interrupt(void)
{
    c428:	0f 12       	push	r15		
    c42a:	0e 12       	push	r14		
    c42c:	0d 12       	push	r13		
    c42e:	0c 12       	push	r12		
     if (IFG2 & UCB0TXIFG) {
    c430:	5f 42 03 00 	mov.b	&0x0003,r15	
    c434:	3f f2       	and	#8,	r15	;r2 As==11
    c436:	1e 42 42 02 	mov	&0x0242,r14	
    c43a:	0f 93       	tst	r15		
    c43c:	05 24       	jz	$+12     	;abs 0xc448
          i2c_callbacks->transmit(&UCB0TXBUF);
    c43e:	3f 40 6f 00 	mov	#111,	r15	;#0x006f
    c442:	9e 12 02 00 	call	2(r14)		;0x0002(r14)
    c446:	03 3c       	jmp	$+8      	;abs 0xc44e
     } else {
          i2c_callbacks->receive(UCB0RXBUF);
    c448:	5f 42 6e 00 	mov.b	&0x006e,r15	
    c44c:	ae 12       	call	@r14		
     }
}
    c44e:	3c 41       	pop	r12		
    c450:	3d 41       	pop	r13		
    c452:	3e 41       	pop	r14		
    c454:	3f 41       	pop	r15		
    c456:	00 13       	reti			

0000c458 <i2c_state_interrupt>:

interrupt(USCIAB0RX_VECTOR) i2c_state_interrupt(void)
{
    c458:	0f 12       	push	r15		
    c45a:	0e 12       	push	r14		
    c45c:	0d 12       	push	r13		
    c45e:	0c 12       	push	r12		
     UCB0STAT &= ~UCSTTIFG;
    c460:	f2 f0 fd ff 	and.b	#-3,	&0x006d	;#0xfffd
    c464:	6d 00 
     i2c_callbacks->start();
    c466:	1f 42 42 02 	mov	&0x0242,r15	
    c46a:	9f 12 04 00 	call	4(r15)		;0x0004(r15)
}
    c46e:	3c 41       	pop	r12		
    c470:	3d 41       	pop	r13		
    c472:	3e 41       	pop	r14		
    c474:	3f 41       	pop	r15		
    c476:	00 13       	reti			

0000c478 <_unexpected_>:
    c478:	00 13       	reti			

Disassembly of section .vectors:

0000ffe0 <__ivtbl_16>:
    ffe0:	4e c0 4e c0 54 c2 b2 c2 4e c0 4e c0 28 c4 58 c4     N.N.T...N.N.(.X.
    fff0:	4e c0 4e c0 4e c0 4e c0 4e c0 4e c0 4e c0 00 c0     N.N.N.N.N.N.N...
